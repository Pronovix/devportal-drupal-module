<?php

use Drupal\Core\Form\FormStateInterface;
use Drupal\devportal_api_reference\Plugin\MigrationConfigDeriver;
use Drupal\file\Entity\File;
use Drupal\Component\Utility\Html;

/**
 * Implements hook_theme().
 */
function devportal_api_reference_theme($existing, $type, $theme, $path) {
  $theme = [];
  $theme['api_ref'] = [
    'render element' => 'elements',
    'file' => 'api_ref.page.inc',
    'template' => 'api-ref',
  ];
  return $theme;
}

/**
 * Implements hook_menu_links_discovered_alter().
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 */
function devportal_api_reference_menu_links_discovered_alter(&$links) {
  // Add menu links for bundles.
  foreach (\Drupal::entityTypeManager()->getStorage("api_ref_type")->loadMultiple() as $type) {
    $links["entity.api_ref.add." . $type->id()] = [
      'title' => t($type->label()),
      'route_name' => "entity.api_ref.add_form",
      'parent' => "entity.api_ref.add_page",
      'route_parameters' => ["api_ref_type" => $type->id()],
    ];
  }
}

/**
 * Implements hook_theme_suggestions_HOOK().
 */
function devportal_api_reference_theme_suggestions_api_ref(array $variables) {
  $suggestions = [];
  /** @var \Drupal\devportal_api_reference\Entity\APIRef $entity */
  $entity = $variables['elements']['#api_ref'];
  $sanitized_view_mode = strtr($variables['elements']['#view_mode'], '.', '_');

  $suggestions[] = $entity->getEntityTypeId() . '__' . $sanitized_view_mode;
  $suggestions[] = $entity->getEntityTypeId() . '__' . $entity->bundle();
  $suggestions[] = $entity->getEntityTypeId() . '__' . $entity->bundle() . '__' . $sanitized_view_mode;
  $suggestions[] = $entity->getEntityTypeId() . '__' . $entity->id();
  $suggestions[] = $entity->getEntityTypeId() . '__' . $entity->id() . '__' . $sanitized_view_mode;

  return $suggestions;
}

/**
 * Implements hook_views_data_alter().
 *
 * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
 */
function devportal_api_reference_views_data_alter(array &$data) {
  // Entity reference base fields should have a reverse relationship in Views
  // (just like the sitebuilder-added entity reference fields have), not only
  // a forward relationship.
  // @see core_field_views_data()
  $entity_type_manager = \Drupal::entityTypeManager();
  /** @var \Drupal\Core\Entity\EntityFieldManager $entity_field_manager */
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $entity_types = $entity_type_manager->getDefinitions();
  foreach ($entity_types as $source_entity_type_id => $source_entity_type) {
    // Handle only our own entity types as source.
    if ($source_entity_type->getProvider() != 'devportal_api_reference') {
      continue;
    }
    // Handle only content entity types as source.
    if (!($source_entity_type instanceof ContentEntityType)) {
      continue;
    }
    $base_field_definitions = $entity_field_manager->getBaseFieldDefinitions($source_entity_type_id);
    foreach ($base_field_definitions as $base_field_id => $base_field_definition) {
      // Handle only entity reference fields.
      if ($base_field_definition->getType() != 'entity_reference') {
        continue;
      }
      /** @var \Drupal\Core\Field\TypedData\FieldItemDataDefinition $item_definition */
      $item_definition = $base_field_definition->getItemDefinition();
      $field_definition = $item_definition->getFieldDefinition();
      $field_storage = $field_definition->getFieldStorageDefinition();
      $target_entity_type_id = $field_storage->getSetting('target_type');
      $target_entity_type = $entity_type_manager->getDefinition($target_entity_type_id);
      // Handle only our own entity types as target.
      if ($target_entity_type->getProvider() != 'devportal_api_reference') {
        continue;
      }
      // Handle only content entity types as target.
      if (!($target_entity_type instanceof ContentEntityType)) {
        continue;
      }

      // Here comes the heart of the dance.
      $pseudo_field_name = 'reverse__' . $source_entity_type_id . '__' . $base_field_id;
      $args = [
        '@label' => $target_entity_type->getLabel(),
        '@field_name' => $base_field_definition->getName(),
        '@entity' => $source_entity_type->getLabel(),
      ];
      // The sitebuilder-added entity reference fields have the same storage
      // schema regardless their cardinality. Sadly, this is not true for entity
      // reference base fields: multi-value fields (ones with cardinality != 1)
      // have a link table between the source and the target entities (just like
      // sitebuilder-added fields have one regardless their cardinality).
      if ($base_field_definition->isMultiple()) {
        $views_table = $target_entity_type->getDataTable();
        $field_table = $source_entity_type_id . '__' . $base_field_id;
        $field_field = $base_field_id . '_' . $base_field_definition->getMainPropertyName();
        $data[$views_table][$pseudo_field_name]['relationship'] = [
          'title' => t('@entity using @field_name', $args),
          'label' => t('Rev: @entity', $args),
          'group' => $target_entity_type->getLabel(),
          'help' => t('Relate each @entity with the @field_name field set to the @label.', $args),
          'id' => 'entity_reverse',
          'base' => $source_entity_type->getDataTable(),
          //'entity_type' => $source_entity_type_id,
          'base field' => $source_entity_type->getKey('id'),
          //'base field' => 'entity_id',
          'field_name' => $source_entity_type_id . '_' . $base_field_id,
          'field table' => $field_table,
          'field field' => $field_field,
          'join_extra' => [
            [
              'field' => 'deleted',
              'value' => 0,
              'numeric' => TRUE,
            ],
          ],
        ];
      }
      else {
        $field_table = $target_entity_type->getDataTable();
        $field_field = $base_field_id;
        // Cannot use the `entity_reverse` @ViewsRelationship handler plugin here,
        // since it always creates two JOINS, which is totally unneeded for
        // single-value baseFields, because their value is available right away on
        // the entity_type_field_data table.
        $data[$field_table][$pseudo_field_name]['relationship'] = [
          'title' => t('@entity using @field_name', $args),
          'label' => t('Rev: @entity', $args),
          'group' => $target_entity_type->getLabel(),
          'help' => t('Relate each @entity with the @field_name field set to the @label.', $args),
          'id' => 'standard',
          'base' => $source_entity_type->getDataTable() ?: $source_entity_type->getBaseTable(),
          'entity type' => $target_entity_type_id,
          'base field' => $base_field_id,
          'relationship field' => $target_entity_type->getKey('id'),
        ];
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function devportal_api_reference_form_node_api_reference_swagger_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['#validate'][] = 'devportal_api_reference_swagger_save';
}

/**
 * Validation function api_reference_swagger.
 *
 * @param array $form
 *   The form array.
 * @param Drupal\Core\Form\FormStateInterface $form_state
 *   The form_state object.
 */
function devportal_api_reference_swagger_save(array $form, FormStateInterface $form_state) {
  try {
    $swagger = NULL;
    $source = $form_state->getValue('source');
    if ($fid = isset($source[0]["fids"][0]) ? $source[0]["fids"][0] : NULL) {
      $file = File::load($fid);
      $swagger = MigrationConfigDeriver::parseSwagger($file->getFileUri());
      $form_state->setValue('title', $swagger['info']['title']);
      $form_state->setValue('version', $swagger['info']['version']);
      $form_state->setValue('description', $swagger['info']['description']);
    }
  }
  catch (\Exception $e) {
    \Drupal::messenger()->addError($e->getMessage());
    $form_state->unsetValue('source');
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Drupal\devportal_api_reference\Plugin\Swagger20ValidationException
 */
function devportal_api_reference_form_node_api_reference_swagger_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['#validate'][] = 'devportal_api_reference_swagger_edit_form_validate';

  // Load node and get node ID. This information will be useful later.
  $node = $form_state->getFormObject()->getEntity();
  $node_id = $node->nid->value;

  // Check the triggering element. If the triggering element is a link the
  // triggering element property will be set to null. If it is from an AJAX
  // request (in this case clicking the 'browse' button and uploading a file) it
  // will have an object assigned to it. By default set the default_value to
  // null.
  $triggering_element = $form_state->getTriggeringElement();
  if ($triggering_element === NULL) {
    $form["source"]["widget"][0]["#default_value"] = NULL;
  }

  // Get the revisions of this node, and create an array of the files contained
  // in these revisions. This array will be used to populate the 'Previously
  // uploaded files' fieldset.
  $previous_files = devportal_api_reference_get_previous_files($node_id);

  // Create the 'Previously uploaded files' fieldset and populate it with the
  // files from the $previous_files array.
  $form['previous_files'] = [
    '#type' => 'details',
    '#weight' => -2,
    '#title' => t('Previously uploaded files'),
    '#open' => TRUE,
  ];
  /** @var \Drupal\file\FileInterface $file */
  foreach ($previous_files as $file) {
    $swagger = MigrationConfigDeriver::parseSwagger($file->getFileUri());
    $form['previous_files'][] = [
      '#theme' => 'file_link',
      '#file' => $file,
      '#description' => Html::escape("{$file->getFilename()} ({$swagger['info']['version']})"),
      '#cache' => [
        'tags' => $file->getCacheTags(),
      ],
    ];
  }
}

/**
 * Validation function for api_reference_swagger_edit_form.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form_state object.
 */
function devportal_api_reference_swagger_edit_form_validate(array $form, FormStateInterface $form_state) {
  // Load node and get node ID. This information will be useful later.
  $node = $form_state->getFormObject()->getEntity();
  $node_id = $node->nid->value;

  $source = $form_state->getValue('source');
  $swagger = NULL;
  try {
    if ($fid = isset($source[0]["fids"][0]) ? $source[0]["fids"][0] : NULL) {
      $file = File::load($fid);
      $swagger = MigrationConfigDeriver::parseSwagger($file->getFileUri());
    }

    $previous_files = devportal_api_reference_get_previous_files($node_id);
    foreach ($previous_files as $file) {
      $previous_swagger_file = MigrationConfigDeriver::parseSwagger($file->getFileUri());
      if ($swagger['info']['version'] === $previous_swagger_file['info']['version']) {
        \Drupal::messenger()->addError('This version has been added before.');
        $form_state->unsetValue('source');
        return NULL;
      }
    }
  }
  catch (\Exception $e) {
    \Drupal::messenger()->addError($e->getMessage());
    $form_state->unsetValue('source');
  }

  try {
    if ($fid = isset($source[0]["fids"][0]) ? $source[0]["fids"][0] : NULL) {
      $file = File::load($fid);
      $swagger = MigrationConfigDeriver::parseSwagger($file->getFileUri());
      $form_state->setValue('title', $swagger['info']['title']);
      $form_state->setValue('version', $swagger['info']['version']);
      $form_state->setValue('description', $swagger['info']['description']);
    }
  }
  catch (\Exception $e) {
    \Drupal::messenger()->addError($e->getMessage());
    $form_state->unsetValue('source');
  }
}

/**
 * Returns the files previously added to the node.
 *
 * @param int $node_id
 *   The node ID.
 *
 * @return array|null
 *   An array of objects containing the previously added files.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 */
function devportal_api_reference_get_previous_files($node_id) {
  $previous_files = NULL;
  $query = \Drupal::entityQuery('node');
  $revision_ids = $query
    ->condition('nid', $node_id)
    ->allRevisions()
    ->execute();
  foreach ($revision_ids as $vid => $nid) {
    /** @var \Drupal\node\NodeInterface $revision */
    $revision = \Drupal::entityTypeManager()
      ->getStorage('node')
      ->loadRevision($vid);
    $source = $revision->get('source')->getValue();
    $previous_files[] = File::load($source[0]["target_id"]);
  }
  return $previous_files;
}
