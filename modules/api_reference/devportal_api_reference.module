<?php

/**
 * @file
 * Main module file for Devportal API Reference.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\devportal_api_reference\Plugin\MigrationConfigDeriver;
use Drupal\file\Entity\File;
use Drupal\Component\Utility\Html;
use Drupal\Core\Entity\ContentEntityInterface;
use Drupal\filter\Entity\FilterFormat;

/**
 * Provides the list of API Reference related node bundles.
 *
 * @return array
 *   An array of node bundles.
 */
function devportal_api_reference_bundles() {
  return ['api_ref_swagger_20'];
}

/**
 * Implements hook_modules_installed().
 *
 * @param array $modules
 */
function devportal_api_reference_modules_installed($modules) {
  // The devportal module only provides the github_flavored_markdown filter
  // format, devportal_api_reference enables it during install.
  // Make sure that the devportal module has been installed, before trying to
  // enable the filter format.
  if (in_array('devportal', $modules)) {
    FilterFormat::load('github_flavored_markdown')->enable()->save();
  }
}

/**
 * Implements hook_menu_links_discovered_alter().
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 */
function devportal_api_reference_menu_links_discovered_alter(&$links) {
  // Add menu links for API Reference bundles.
  foreach (\Drupal::entityTypeManager()->getStorage('node_type')->loadMultiple() as $type) {
    if (in_array($type->id(), devportal_api_reference_bundles(), TRUE)) {
      // Menu link for node add form.
      $links["entity.api_ref.add.{$type->id()}"] = [
        'title' => 'Add ' . t($type->label()),
        'parent' => 'entity.api_ref.collection',
        'route_name' => 'node.add',
        'route_parameters' => [
          'node_type' => $type->id()
        ],
      ];
      // Menu link for node bundle configuration.
      $links["entity.api_ref.configuration.{$type->id()}"] = [
        'title' => t($type->label()),
        'parent' => 'system.admin_devportal_config',
        'description' => t("Manage {$type->label()} configuration."),
        'route_name' => 'entity.node_type.edit_form',
        'route_parameters' => [
          'node_type' => $type->id()
        ],
      ];
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function devportal_api_reference_form_node_api_ref_swagger_20_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form["field_source_file"]["widget"][0]["#required"] = TRUE;
  $form['#validate'][] = 'devportal_api_reference_api_ref_swagger_20_validate';
}

/**
 * Custom validation function api_ref_swagger_20 node bundle.
 *
 * @param array $form
 *   The form array.
 * @param Drupal\Core\Form\FormStateInterface $form_state
 *   The form_state object.
 */
function devportal_api_reference_api_ref_swagger_20_validate(array $form, FormStateInterface $form_state) {
  try {
    $swagger = NULL;
    $source = $form_state->getValue('field_source_file');
    if ($fid = isset($source[0]["fids"][0]) ? $source[0]["fids"][0] : NULL) {
      $file = File::load($fid);
      $swagger = MigrationConfigDeriver::parseSwagger($file->getFileUri());
      $form_state->setValue('title', $swagger['info']['title']);
      $form_state->setValue('field_version', $swagger['info']['version']);
      $form_state->setValue('field_description', [
        'value' => $swagger['info']['description'],
        'format' => 'github_flavored_markdown',
      ]);
    }
  }
  catch (\Exception $e) {
    \Drupal::messenger()->addError($e->getMessage());
    $form_state->unsetValue('field_source_file');
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Exception
 */
function devportal_api_reference_form_node_api_ref_swagger_20_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $form['#validate'][] = 'devportal_api_reference_api_ref_swagger_20_edit_form_validate';
  /** @var \Drupal\node\Entity\Node $node */
  $node = $form_state->getFormObject()->getEntity();

  // Check the triggering element. If the triggering element is a link the
  // triggering element property will be set to NULL. If it is from an AJAX
  // request (in this case clicking the 'browse' button and uploading a file) it
  // will have an object assigned to it. By default set the default_value to
  // NULL.
  if ($form_state->getTriggeringElement() === NULL) {
    $form_state->set('field_source_file_tmp', $form["field_source_file"]["widget"][0]["#default_value"]);
    $form["field_source_file"]["widget"][0]["#default_value"] = NULL;
  }

  // Get the revisions of this node, and create an array of the files contained
  // in these revisions. This array will be used to populate the 'Previously
  // uploaded files' fieldset.
  $previous_files = devportal_api_reference_get_previous_files($node->id());

  // Create the 'Previously uploaded files' fieldset and populate it with the
  // files from the $previous_files array.
  $form['previous_files'] = [
    '#type' => 'details',
    '#weight' => -2,
    '#title' => t('All uploaded files'),
    '#open' => TRUE,
  ];
  /** @var \Drupal\file\FileInterface $file */
  foreach ($previous_files as $file) {
    $swagger = MigrationConfigDeriver::parseSwagger($file->getFileUri());
    $form['previous_files'][] = [
      '#theme' => 'file_link',
      '#file' => $file,
      '#description' => Html::escape("{$file->getFilename()} ({$swagger['info']['version']})"),
      '#cache' => [
        'tags' => $file->getCacheTags(),
      ],
    ];
  }
}

/**
 * Validation function for api_ref_swagger_20_edit_form.
 *
 * @param array $form
 *   The form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form_state object.
 *
 * @return void|boolean
 */
function devportal_api_reference_api_ref_swagger_20_edit_form_validate(array $form, FormStateInterface $form_state) {
  /** @var \Drupal\node\Entity\Node $node */
  $node = $form_state->getFormObject()->getEntity();

  $source = $form_state->getValue('field_source_file');
  $swagger = NULL;
  try {
    if ($fid = isset($source[0]["fids"][0]) ? $source[0]["fids"][0] : NULL) {
      $file = File::load($fid);
      $swagger = MigrationConfigDeriver::parseSwagger($file->getFileUri());
    }

    if (devportal_api_reference_check_api_version($node, $swagger['info']['version'])) {
      \Drupal::messenger()->addError('This version has been added before.');
      $form_state->unsetValue('field_source_file');
      return NULL;
    }

    if ($fid = isset($source[0]["fids"][0]) ? $source[0]["fids"][0] : NULL) {
      $file = File::load($fid);
      $swagger = MigrationConfigDeriver::parseSwagger($file->getFileUri());
      $form_state->setValue('title', $swagger['info']['title']);
      $form_state->setValue('field_version', $swagger['info']['version']);
      $form_state->setValue('field_description', [
        'value' => $swagger['info']['description'],
        'format' => 'github_flavored_markdown',
      ]);
    }
    else {
      // If no source file was uploaded use the last uploaded source file.
      $source[0]["fids"][0] = $form_state->get('field_source_file_tmp')["fids"][0];
      $form_state->setValue('field_source_file', $source);
    }
  }
  catch (\Exception $e) {
    \Drupal::messenger()->addError($e->getMessage());
    $form_state->unsetValue('field_source_file');
  }
}

/**
 * Checks whether a given API documentation version already exist or not.
 *
 * @param \Drupal\node\Entity\Node $node
 *   The API Reference node entity.
 * @param $version
 *   The API version to check.
 *
 * @return boolean
 *   Returns TRUE if the given API version already exist. Returns FALSE
 *   otherwise.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 * @throws \Exception
 */
function devportal_api_reference_check_api_version(\Drupal\node\Entity\Node $node, $version) {
  $previous_files = devportal_api_reference_get_previous_files($node->id());
  foreach ($previous_files as $file) {
    $previous_file = MigrationConfigDeriver::parseSwagger($file->getFileUri());
    if ($version === $previous_file['info']['version']) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Returns the files previously added to the node.
 *
 * @param int $nid
 *   The node ID.
 *
 * @return array
 *   An array of objects containing the previously added files.
 *
 * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
 */
function devportal_api_reference_get_previous_files($nid) {
  $previous_files = [];

  $query = \Drupal::entityQuery('node');
  $revision_ids = $query
    ->condition('nid', $nid)
    ->allRevisions()
    ->execute();
  foreach ($revision_ids as $vid => $nid) {
    /** @var \Drupal\node\NodeInterface $revision */
    $revision = \Drupal::entityTypeManager()
      ->getStorage('node')
      ->loadRevision($vid);
    $source = $revision->get('field_source_file')->getValue();
    if (!empty($source)) {
      $previous_files[] = File::load($source[0]["target_id"]);
    }
  }
  // If, for example, the published setting is toggled Drupal will create a new
  // revision. In this case Drupal will list that revision in the revisions
  // list, thus it will be deletable or revertable through the UI.
  // But... we still have the same number of flies uploaded. We need to remove
  // the duplicate files from the list of previous files.
  return devportal_api_reference_get_unique_files($previous_files);
}

/**
 * Return objects with unique files from the previous_files array.
 *
 * @param array $array
 *   The array of objects to be checked.
 *
 * @return array
 *   Returns an array of unique objects.
 */
function devportal_api_reference_get_unique_files(array $array) {
  $duplicate_keys = [];
  $tmp = [];
  foreach ($array as $key => $val) {
    $uri = $val->getFileUri();
    if (!in_array($uri, $tmp) && file_exists($uri)) {
      $tmp[] = $uri;
    }
    else {
      $duplicate_keys[] = $key;
    }
  }
  foreach ($duplicate_keys as $key) {
    unset($array[$key]);
  }
  return $array;
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function devportal_api_reference_node_presave(ContentEntityInterface $entity) {
  if ($entity->bundle() === 'api_ref_swagger_20') {
    // Force set revision_translation_affected column in node_field_revision
    // table to TRUE, so that all revisions in the database will be viewable on
    // the /node/{nid}/revisions page.
    $entity->setRevisionTranslationAffected(TRUE);
  }
}

/**
 * Implements hook_modules_installed().
 */
function devportal_api_reference_modules_installed($modules) {
  // The devportal module only provides the github_flavored_markdown filter
  // format, devportal_api_reference enables it during install.
  // Make sure that the devportal module has been installed before trying to
  // enable the filter format.
  if (in_array('devportal', $modules)) {
    FilterFormat::load('github_flavored_markdown')->enable()->save();
  }
}
